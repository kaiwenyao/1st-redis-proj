### 缓存穿透Cache Penetration

如果发起查询请求，查询一个***不存在的内容***，比如id=-1，就会导致每次redis中都查不到 --> 每次都要去数据库中查找，大大增加压力。

所以，当数据库发现没有这个数据的时候，要把一个**空值**存储到redis。下次再查询这个不存在的内容，就直接返回redis中这个空值。

### 缓存击穿 Cache Breakdown

redis中的数据有ttl 会过期。

如果如果在过期时，恰好有很大量的请求发送，则这些请求发现redis中没有，都会去数据库中进行查询。

解决办法：***互斥锁***，**逻辑过期**

#### 互斥锁方法

第一个发现redis中不存在数据的线程，尝试获取锁，一旦获取到，就去数据库中进行查询和保存到redis。后面的进程虽然发现redis中不存在数据，但是拿不到锁，就没办法去找数据库。只能等之前的线程去数据库中找到，然后从redis中读取。

互斥锁的实现：在redis中利用setnx添加数据。当数据存在时，无事发生；当数据不存在时，成功添加。若成功添加，则为成功获得锁。

#### 逻辑过期

加上了逻辑过期函数。

>  注意！这个commit的逻辑过期函数，只针对现有redis缓存的更新。不包含新建redis缓存。所以在使用时，不得不先用测试类中的方法在Redis中新建一条数据，然后在数据库中进行修改数据，然后再做并发请求测试。

也就是说：逻辑过期方案有一个**硬性前提**——**所有热点数据必须提前预热（Pre-heat）加载到 Redis 中**。如果 Redis 里没有，就默认视为“该商品不存在”或“不在活动中”，直接拒绝服务。

例如：

1. redis中新建一个数据，包含data和过期时间。假设是店铺1，过期时间10秒钟
2. 在mysql中修改data 的内容
3. 等待10秒钟过去，redis中已经过期
4. 运行后端，做并发请求

这个时候并发请求到了后端，第一个请求会拿到锁，去mysql中找数据，然后重写redis；但是其他请求直接拿到redis中的过期数据做了返回。当第一个请求完成之后，后面来的请求就是最新的数据了。

*此实战项目结束！*

### 封装工具类

代码解读之缓存击穿和缓存穿透。文件位置：

`com.hmdp.utils.CacheClient`

```java
public <R, ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type,
                                      Function<ID, R> dbFallback,
                                      Long time, TimeUnit timeUnit) 
```

这个函数的声明用到了**泛型（Generics）** 和 **函数式编程（Functional Programming）**。

#### 第一部分：`<R, ID>` —— 声明“未知数”

```java
public <R, ID> R ...
```

这是 Java **泛型方法** 的标志。

- **含义：** 在这段代码里，`R` 和 `ID` 不是具体的类名，而是两个 **“代号”**（占位符）。
  - **`R` (Result)**：代表 **“返回值的类型”**。它可以是 `Shop`，可以是 `User`，也可以是 `Blog`。
  - **`ID` (Identifier)**：代表 **“查询主键的类型”**。它可以是 `Long`（数字id），也可以是 `String`（uuid）。
- **为什么要写在 `public` 后面？** 这相当于在告诉编译器：“嘿，老兄，接下来的参数里会出现 `R` 和 `ID` 这两个词，它们是我定义的变量，不是写错字了哈！”

#### 第二部分：`R` —— 真正的返回值

```java
... R queryWithPassThrough(...)
```

**含义：** 这个方法执行完后，会吐出一个类型为 `R` 的东西。

**动态变化：**

- 如果你查店铺，`R` 就自动变成 `Shop`。
- 如果你查用户，`R` 就自动变成 `User`。

#### 第三部分：`Class<R> type` —— 告诉 JSON 转成谁

```java
... Class<R> type ...
```

**这是什么？** 这叫 **Class 对象（类型令牌）**。

**为什么要传它？** Redis 里存的数据是 **JSON 字符串**（比如 `"{ "name": "麦当劳" }"`）。 当你从 Redis 拿出来字符串后，你需要用工具（比如 `JSONUtil.toBean`）把它转成 Java 对象。 但是工具不知道要转成 `Shop` 还是 `User`。

**作用：** 所以你需要把 `Shop.class` 当作参数传进去，告诉工具：“请照着 `Shop` 的图纸，把这个字符串还原成对象。”

#### 第四部分：`Function<ID, R> dbFallback` —— 核心难点

```java
... Function<ID, R> dbFallback ...
```

这是 Java 8 引入的 **函数式接口**。

- **通俗解释：** 这代表 **“一段逻辑”** 或 **“一个函数”**。
- **以往的做法：** 我们传参通常传的是“数据”（比如 id, name）。
- **现在的做法：** 这里传的是 **“如果 Redis 没查到，去数据库怎么查的逻辑”**。
- **解读 `<ID, R>`：**
  - 这个函数接收一个 `ID` 类型的参数（比如店铺 id）。
  - 这个函数返回一个 `R` 类型的结果（比如店铺对象）。
- **为什么叫 `Fallback`（兜底）？** 这个函数只有在 Redis 查不到（缓存穿透/击穿）的时候，才会被这个通用方法调用。调用时，它会执行你传入的 `getById(id)` 逻辑。







### 总结

解决了缓存穿透和击穿的问题。封装了工具类。

