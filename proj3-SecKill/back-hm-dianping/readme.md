### 缓存穿透Cache Penetration

如果发起查询请求，查询一个***不存在的内容***，比如id=-1，就会导致每次redis中都查不到 --> 每次都要去数据库中查找，大大增加压力。

所以，当数据库发现没有这个数据的时候，要把一个**空值**存储到redis。下次再查询这个不存在的内容，就直接返回redis中这个空值。

### 缓存击穿 Cache Breakdown

redis中的数据有ttl 会过期。

如果如果在过期时，恰好有很大量的请求发送，则这些请求发现redis中没有，都会去数据库中进行查询。

解决办法：***互斥锁***，**逻辑过期**

#### 互斥锁方法

第一个发现redis中不存在数据的线程，尝试获取锁，一旦获取到，就去数据库中进行查询和保存到redis。后面的进程虽然发现redis中不存在数据，但是拿不到锁，就没办法去找数据库。只能等之前的线程去数据库中找到，然后从redis中读取。

互斥锁的实现：在redis中利用setnx添加数据。当数据存在时，无事发生；当数据不存在时，成功添加。若成功添加，则为成功获得锁。

#### 逻辑过期

加上了逻辑过期函数。

注意！这个commit的逻辑过期函数，只针对现有redis缓存的更新。不包含新建redis缓存。所以在使用时，不得不先用测试类中的方法在Redis中新建一条数据，然后在数据库中进行修改数据，然后再做并发请求测试。

例如：

1. redis中新建一个数据，包含data和过期时间。假设是店铺1，过期时间10秒钟
2. 在mysql中修改data 的内容
3. 等待10秒钟过去，redis中已经过期
4. 运行后端，做并发请求

这个时候并发请求到了后端，第一个请求会拿到锁，去mysql中找数据，然后重写redis；但是其他请求直接拿到redis中的过期数据做了返回。当第一个请求完成之后，后面来的请求就是最新的数据了。

*此实战项目结束！*

### 总结

解决了缓存穿透和击穿的问题。封装了工具类。